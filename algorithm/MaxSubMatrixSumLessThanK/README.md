问题：给定一个无序矩阵，其中有正，有负，有0，再给定一个值k，求累加和小于等于k的最大子矩阵大小，矩阵的大小用其中的元素个数来表示。  
可不可以直接用 求子数组累加和等于k的最长子数组长度 的算法套进去的，用滑动窗口？  
窗口内值的累加和小于等于k，右边界向右滑动一步，否则左边界向右滑动一步。窗口大小就是累加和小于等于k的子数组长度，每次都比较窗口大小记下最大值。  
不对，滑动窗口之所以可行是因为数组中元素都是正数，确保了每次左边抛弃的值都是不需要的。  
这里题目矩阵元素中是有负数的，有这样一种情况：  
假设k=-3，数组为-1，-2，-2，3  
那么因为-1>k，会直接抛弃掉-1。同理后面的-2，-2，3也都被抛弃了，最后得出错误结果0。  
这里有个解决方法不知道可不可行，就是如果碰到窗口累加和是负数，就直接右边界右移不抛弃值。emm不可以，因为你不能确保最后的窗口累加和是小于等于k的。  
所以滑动窗口pass  
  
算法原型是求累加和小于等于k的最长子数组的长度。  
算法原型解法：  
设0到当前位置j累加和是sum[j]，如果sum[j]<=k,那么0到j就是累加和小于等于k的子数组长度；如果sum[j]>k，那么找出0到j之间累加和第一次大于等于sum[j]-k的位置i，该位置到j就是就是要求的最大长度。因为sum[i]+sum[i+1 ~ j]=sum[j]>k，所以只要sum[i]>=sum[j]-k，那么一定有sum[i+1~j]<=k。  
先算出累加和数组sum，再找出每一个位置对应的i，找i这里有个优化，用一个数组记录区域最大累加和，然后可以在这个数组上用二分查找查出第一个大于等于k的位置i。