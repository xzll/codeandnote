**矩阵元素有正有负有零，求子矩阵最大和。**  
先想到暴力解法，以求子数组最大累加和为基础。先每一行分别按照求子数组最大累加和的方法得出max，再每两行接着求，再每三行接着求。。。最后n行一起求，就能得到最大累加和了。  
比如，数组a[4][4]。  
先求a[0]数组的最大累加和max，  
再求a[1]数组的最大累加和，和max比较，记最大的，  
...  
最后求a[3]数组；  

一行的求完了，求两行的。  
求a[0]+a[1]数组的最大累加和，和max比较，记最大的，(a[0]+a[1]数组表示第1行和第2行对应元素相加后得到的数组)  
求a[1]+a[2]数组的最大累加和，和max比较，记最大的，  
求a[2]+a[3]数组的最大累加和，和max比较，记最大的；  

两行的求完了求三行的；  
求a[0]+a[1]+a[2]数组的最大累加和，和max比较，记最大的，  
求a[1]+a[2]+a[3]数组的最大累加和，和max比较，记最大的，  
三行的求完了求四行的；  
求a[0]+a[1]+a[2]+a[3]数组的最大累加和，和max比较，记最大的。  

好了，都把所有可能的子矩阵遍历完了，最后的max就是最大累加和。  
时间复杂度：~~O(n2m) n行数，m列数。方阵的话是O(n3)~~ 复杂度算不明白。。  
  
实际解法思路跟我想的差不多，只不过优化了很多，时间复杂度是O(n3)。 
 
它不是根据行数来遍历而是从a[0]开始遍历一遍，再从a[1]开始遍历一遍。。比如a[4][4]：  
求a[0]数组最大累加和  
求a[0]+a[1] 数组最大累加和  
求a[0]+a[1]+a[2]数组最大累加和  
求a[0]+a[1]+a[2]+a[3]数组最大累加和  

a[0]的遍历完了，遍历包含a[1]的；  
求a[1]数组最大累加和  
求a[1]+a[2]数组最大累加和  
求a[1]+a[2]+a[3]数组最大累加和  

a[1]的遍历完了，遍历包含a[2]的；  
求a[2]数组最大累加和  
求a[2]+a[3]数组最大累加和  

最后求a[3]数组最大累加和。  

这样子也同样能遍历到所有子矩阵，而且还有一个好处，那就是能够用一个辅助数组来存储各行对应元素的和。这样就不用每次都要重新相加元素，时间复杂度相比我的想法会降为O(n3)。