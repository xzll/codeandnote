[左程云的课](https://www.nowcoder.com/live/11/1/1)

题目要求实际上跟leetcode354俄罗斯套娃是一样的。

> 给定一个N\*2的二维数组，看作是一个个二元组，例如[[a1,b1],[a2,b2],[a3,b3]]，规定：一个如果想把二元组甲放在二元组乙上，甲中的a值必须大于乙中a值，甲中的b值必须大于乙中的b值。如果在二维数组中随意选择二元组，请问二元组最多可以往上摞几个？
要求：实现时间复杂度O(NlogN)的解法。

不考虑时间复杂度，最先想到排序，先根据a升序排序a相同根据b排序。
诶~问题来了，根据a再根据b排序后的序列要怎么知道最多能摞多少呢？
如：（1，2），（2，7），（3，4），（3，7），（4，5），这个序列是根据该规则排序的那么怎么知道最多能摞多少个二元组？
（1，2），（2，7） 2个
（1，2），（3，4），（3，7）3个
（1，2），（3，4），（4，5）3个
算法原型：最长递增子序列，它的长度就是要的值
#### O(n^2)解法：
用一个辅助数组dp记录**以当前元素为子序列末尾 的 子序列的最大长度**。

（1，2），（2，7），（3，4），（3，7），（4，5）排好序的二元组
1   dp[]
1，2
1，2，2
1，2，2，3
1，2，2，3，3
时间复杂度为O(n^2)，因为对于每个元素，都要遍历之前的元素，找出dp[i]最大的小于当前元素的元素。

#### O(nlogn)的解法
给辅助数组换一种意义，记录长度为i的递增子序列的**最小末尾**。
找到**第一个大于当前的数**，有就替换，没有就放在末尾。（二分查找）
相同呢？
每个数都会是最小末尾只不过可能会被后来的数覆盖。
3，5，1，4，8，6
3
3，5  
1，5  
1，4 
1，4，8 
1，4，6 
然后对于二元组，排列规则就出问题了，**怎么确定那个元素大呢？**
如（2，7）（3，4）哪个小哪个大？
如果只根据a判断的话（3，4）大
a相同判断b，取b小的
（1，2），（2，7），（3，4），（3，5），（4，5）-----新的序列
（1，2），
（1，2），（2，7）
（1，2），（2，7），（3，4）
（1，2），（2，7），（3，4）
（1，2），（2，7），（3，4），（4，5）
如果只根据b判断的话（2，7）大，（1，5）也比（3，4）大，
a相同判断b，取b小的
会变成这样 👇，好像没什么毛病
（1，5），（2，7），（3，4），（3，6），（4，7）---- 新的序列
（1，5），
（1，5），（2，7）
（3，4），（2，7）
（3，4），（3，6）
（3，4），（3，6），（4，7）


按照**a升序，同a则b降序**来排序，并且只根据b来找出最大递增子序列就不会出各种各样的问题。
b降序可以确保后面b大于前面的话就一定可以叠加起来。否则如（6，4）（6，7）后面的是不能叠在前面之上的。

因为当前元素和前面的元素比较的话有两种情况，
1：当前a与前面a相同，则b不可能比前面大，所以如果碰到了会取代它成为最小末尾，没碰到就当另一个子序列的最小末尾；
2：当前a与前面不同，则当前a一定是大于前面a的，所以b大则元素大。
因此可以直接比较b。

感觉不降序也没事，只是需要在碰到相同a的时候取小b的元素。咦，这样子每次比较就都得判断a不能只把b拿出来判断了。降序666

（1，2），（2，7），（3，5），（3，4），（4，6）
2，7，5，4，6 ----b
2，
2，7
2，5
2，4
2，4，6 ----（1，2），（3，4），（4，6）

（2，5），（3，6），（3，4）
5，6，4
5
5，6
4，6  -----（3，4），（3，6）

（2，3），（3，6），（3，4）
3，6，4
3
3，6
3，4  

（2，5），（3，5），（3，6）
5
5 （2，5）b相同的话比较a取小的
5，6




